// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package collect

type T_T_Map map[T_]T_

func (mp *T_T_Map) Init() (m T_T_Map) {
	if m = *mp; m == nil {
		m = make(T_T_Map)
		*mp = m
	}
	return
}

func (mp *T_T_Map) Put(key T_, val T_) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type T_BooleanMap map[T_]Boolean

func (mp *T_BooleanMap) Init() (m T_BooleanMap) {
	if m = *mp; m == nil {
		m = make(T_BooleanMap)
		*mp = m
	}
	return
}

func (mp *T_BooleanMap) Put(key T_, val Boolean) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type T_IntegerMap map[T_]Integer

func (mp *T_IntegerMap) Init() (m T_IntegerMap) {
	if m = *mp; m == nil {
		m = make(T_IntegerMap)
		*mp = m
	}
	return
}

func (mp *T_IntegerMap) Put(key T_, val Integer) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type StringT_Map map[String]T_

func (mp *StringT_Map) Init() (m StringT_Map) {
	if m = *mp; m == nil {
		m = make(StringT_Map)
		*mp = m
	}
	return
}

func (mp *StringT_Map) Put(key String, val T_) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type StringBooleanMap map[String]Boolean

func (mp *StringBooleanMap) Init() (m StringBooleanMap) {
	if m = *mp; m == nil {
		m = make(StringBooleanMap)
		*mp = m
	}
	return
}

func (mp *StringBooleanMap) Put(key String, val Boolean) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type StringIntegerMap map[String]Integer

func (mp *StringIntegerMap) Init() (m StringIntegerMap) {
	if m = *mp; m == nil {
		m = make(StringIntegerMap)
		*mp = m
	}
	return
}

func (mp *StringIntegerMap) Put(key String, val Integer) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type ShaT_Map map[Sha]T_

func (mp *ShaT_Map) Init() (m ShaT_Map) {
	if m = *mp; m == nil {
		m = make(ShaT_Map)
		*mp = m
	}
	return
}

func (mp *ShaT_Map) Put(key Sha, val T_) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type ShaBooleanMap map[Sha]Boolean

func (mp *ShaBooleanMap) Init() (m ShaBooleanMap) {
	if m = *mp; m == nil {
		m = make(ShaBooleanMap)
		*mp = m
	}
	return
}

func (mp *ShaBooleanMap) Put(key Sha, val Boolean) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}

type ShaIntegerMap map[Sha]Integer

func (mp *ShaIntegerMap) Init() (m ShaIntegerMap) {
	if m = *mp; m == nil {
		m = make(ShaIntegerMap)
		*mp = m
	}
	return
}

func (mp *ShaIntegerMap) Put(key Sha, val Integer) bool {
	m := mp.Init()
	if v, ok := m[key]; ok && v == val {
		return false
	}
	m[key] = val
	return true
}
